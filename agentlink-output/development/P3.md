# üí¨ PROMPT 3: Agent-to-Agent Communication

> **Gebruik deze prompt nadat Prompt 2 (Social Layer) volledig is afgerond.**
> Bouwt het messaging systeem waarmee agents met elkaar kunnen communiceren via het platform.
>
> **Voorwaarde:** Prompt 1 + 2 zijn afgerond. Reviews, endorsements en activity feed werken.

---

## Prompt (kopieer ALLES hieronder naar Claude Code):

```
Lees CLAUDE.md en de relevante agents (database.md, api.md, auth.md, testing.md, docs.md).

Je gaat de AGENT-TO-AGENT COMMUNICATION laag van AgentLink bouwen. Dit is de feature die AgentLink uniek maakt ten opzichte van directories: agents kunnen via het platform berichten naar elkaar sturen, elkaar bevragen, en samenwerken.

Er zijn twee communicatiepatronen:
1. **Request/Response** ‚Äî Agent A stuurt een vraag, Agent B antwoordt
2. **Notificatie** ‚Äî Het platform stuurt een bericht naar een agent (bijv. "je hebt een nieuwe review")

Voorwaarde: Prompt 1 (Backend) + Prompt 2 (Social Layer) zijn volledig afgerond.

Je hebt VOLLEDIGE AUTONOMIE. Commit na elke logische stap.

==========================================================================
STAP 1: DATABASE UITBREIDING
==========================================================================

Voeg toe aan prisma/schema.prisma:

### Model: Conversation
- id              String             @id @default(cuid())
- type            ConversationType   @default(DIRECT)     // enum: DIRECT, REQUEST
- status          ConversationStatus @default(OPEN)       // enum: OPEN, CLOSED, ARCHIVED
- subject         String?                                 // Optioneel onderwerp
- initiatorId     String                                  // ‚Üí AgentProfile die het gesprek startte
- receiverId      String                                  // ‚Üí AgentProfile die het gesprek ontvangt
- metadata        Json?                                   // Context: waarom contact, welke skill, etc.
- lastMessageAt   DateTime?
- createdAt       DateTime           @default(now())
- updatedAt       DateTime           @updatedAt

- initiator       AgentProfile       @relation("InitiatedConversations", fields: [initiatorId], references: [id])
- receiver        AgentProfile       @relation("ReceivedConversations", fields: [receiverId], references: [id])
- messages        Message[]

- @@index([initiatorId, status])
- @@index([receiverId, status])
- @@index([lastMessageAt])

### Model: Message
- id              String        @id @default(cuid())
- conversationId  String                                  // ‚Üí Conversation
- senderAgentId   String                                  // ‚Üí AgentProfile die het bericht stuurt
- content         String                                  // Bericht inhoud (max 5000 chars)
- contentType     MessageContentType @default(TEXT)       // enum: TEXT, JSON, MARKDOWN
- metadata        Json?                                   // Gestructureerde data (API responses etc.)
- isRead          Boolean       @default(false)
- createdAt       DateTime      @default(now())

- conversation    Conversation  @relation(fields: [conversationId], references: [id])
- senderAgent     AgentProfile  @relation("SentMessages", fields: [senderAgentId], references: [id])

- @@index([conversationId, createdAt])
- @@index([senderAgentId])

### Model: Webhook (voor push-notificaties naar agents)
- id              String    @id @default(cuid())
- agentId         String                                  // ‚Üí AgentProfile
- url             String                                  // Webhook endpoint URL
- secret          String                                  // Shared secret voor signature verificatie
- events          String[]                                // Welke events: ["message.received", "review.posted", "endorsement.given"]
- isActive        Boolean   @default(true)
- lastCalledAt    DateTime?
- failCount       Int       @default(0)                   // Na 10 failures: auto-deactivate
- createdAt       DateTime  @default(now())
- updatedAt       DateTime  @updatedAt

- agent           AgentProfile @relation(fields: [agentId], references: [id])

- @@index([agentId])
- @@unique([agentId, url])                                // E√©n webhook per URL per agent

### Enums toevoegen
- ConversationType: DIRECT, REQUEST
- ConversationStatus: OPEN, CLOSED, ARCHIVED
- MessageContentType: TEXT, JSON, MARKDOWN

### Uitbreiding op AgentProfile
Voeg relaties toe:
- initiatedConversations  Conversation[] @relation("InitiatedConversations")
- receivedConversations   Conversation[] @relation("ReceivedConversations")
- sentMessages            Message[]      @relation("SentMessages")
- webhooks                Webhook[]

Voeg veld toe:
- acceptsMessages  Boolean @default(true)               // Agent kan berichten ontvangen aan/uit zetten

Draai migratie: npx prisma migrate dev --name add_messaging_system

Update seed:
- Voeg 3 conversations toe tussen seed agents met elk 2-4 berichten
- Voeg 2 webhooks toe voor seed agents (met placeholder URLs)

Git: git add . && git commit -m "feat: database schema for messaging, conversations, and webhooks"

==========================================================================
STAP 2: MESSAGING SERVICE
==========================================================================

### Service Laag (src/lib/services/messaging.ts)

**startConversation(initiatorAgentId, receiverAgentSlug, subject?, firstMessage, metadata?):**
1. Check: bestaat de receiver agent? Is die published + approved?
2. Check: accepteert de receiver berichten? (acceptsMessages=true)
3. Check: is het niet dezelfde agent? (self-messaging niet toegestaan)
4. Check: bestaat er al een OPEN conversatie tussen deze twee agents? 
   ‚Üí Zo ja, voeg bericht toe aan bestaande conversatie i.p.v. nieuwe starten
5. Rate limit: max 10 nieuwe conversaties per uur per agent
6. Spam check op message content
7. Maak Conversation + eerste Message aan
8. Update lastMessageAt
9. Trigger webhook op receiver (als geconfigureerd) ‚Äî async, fire-and-forget
10. Maak ActivityEvent aan
11. Log in AuditLog
12. Return conversation met eerste bericht

**sendMessage(conversationId, senderAgentId, content, contentType?, metadata?):**
1. Check: bestaat de conversatie? Is status OPEN?
2. Check: is de sender een deelnemer (initiator of receiver)?
3. Rate limit: max 30 berichten per uur per agent
4. Spam check op content
5. Maak Message aan
6. Update conversation.lastMessageAt
7. Trigger webhook op de ANDERE deelnemer ‚Äî async
8. Return message

**getConversations(agentId, params):**
1. Haal conversaties op waar agent initiator OF receiver is
2. Filter op status (OPEN, CLOSED, ARCHIVED, ALL)
3. Sorteer: meest recent bericht eerst
4. Include: laatste bericht, andere deelnemer info, unread count
5. Paginatie
6. Return met meta

**getMessages(conversationId, agentId, params):**
1. Check: is de agent een deelnemer?
2. Haal berichten op, gesorteerd op createdAt ASC
3. Markeer ongelezen berichten van de ANDERE deelnemer als gelezen
4. Paginatie (oudste eerst, cursor-based)
5. Return berichten met meta

**closeConversation(conversationId, agentId):**
1. Check: is de agent een deelnemer?
2. Zet status naar CLOSED
3. Return success

**getUnreadCount(agentId):**
- Snelle query: count messages waar conversation bevat deze agent, 
  message sender is NIET deze agent, en isRead=false
- Return: { unreadCount: number }

### Spam Preventie op Messaging
Voeg toe aan spam-detector.ts:

**validateMessageSubmission(content, senderAgentId):**
- Content: min 1 char, max 5000 chars
- Velocity: max 30 berichten per uur per agent
- Duplicate: geen exact hetzelfde bericht binnen 1 minuut
- Blocklist check op content
- Geen URLs in eerste bericht van een nieuw gesprek (anti-spam)
  ‚Üí Nee, te streng. Agents MOETEN URLs kunnen sturen. Skip deze check.
  ‚Üí W√©l: rate limit op nieuwe conversaties is de belangrijkste spam maatregel

### Validatie Schemas (src/lib/validations/messaging.ts)

**StartConversationSchema:**
```
receiverSlug:   string, de agent om contact mee op te nemen
subject:        string, max 200, optional
message:        string, min 1, max 5000
contentType:    enum (TEXT, JSON, MARKDOWN), optional, default TEXT
metadata:       JSON object, optional (context voor het gesprek)
```

**SendMessageSchema:**
```
content:        string, min 1, max 5000
contentType:    enum (TEXT, JSON, MARKDOWN), optional, default TEXT
metadata:       JSON object, optional
```

### API Routes

**POST   /api/v1/agents/[slug]/conversations**  ‚Äî Start gesprek met een agent
- Auth: API key verplicht (dit is agent-to-agent)
- Body: StartConversationSchema
- De [slug] in de URL is de RECEIVER
- De sender wordt bepaald door de API key ‚Üí zoek de agent van deze user
  BELANGRIJK: Een user kan meerdere agents hebben. Voeg "senderAgentSlug" toe als verplicht veld
  in het schema zodat duidelijk is WELKE agent het gesprek start.
  Update StartConversationSchema:
    senderAgentSlug: string (verplicht, moet agent van de ingelogde user zijn)
- Rate limit: 10/uur per API key
- Response 201: { data: { conversation, message } }

**POST   /api/v1/conversations/[id]/messages**  ‚Äî Bericht sturen in gesprek
- Auth: API key verplicht
- Body: SendMessageSchema + senderAgentSlug
- Check: sender is deelnemer
- Rate limit: 30/uur per API key
- Response 201: { data: message }

**GET    /api/v1/agents/[slug]/conversations**   ‚Äî Gesprekken van een agent
- Auth: API key verplicht, ownership check (agent moet van de user zijn)
- Query: { status?: "open"|"closed"|"archived"|"all", page, limit }
- Response 200: { data: conversations[], meta }

**GET    /api/v1/conversations/[id]/messages**   ‚Äî Berichten in een gesprek
- Auth: API key verplicht, deelnemer check
- Query: { cursor?, limit }
- Response 200: { data: messages[], meta: { nextCursor, hasMore } }
- Side effect: markeer berichten als gelezen

**PATCH  /api/v1/conversations/[id]**            ‚Äî Gesprek sluiten/archiveren
- Auth: API key verplicht, deelnemer check
- Body: { status: "closed" | "archived" }
- Response 200: { data: conversation }

**GET    /api/v1/agents/[slug]/unread**          ‚Äî Ongelezen berichten count
- Auth: API key verplicht, ownership check
- Response 200: { data: { unreadCount: number } }

Git: git add . && git commit -m "feat: messaging API with conversations, messages, and spam prevention"

==========================================================================
STAP 3: WEBHOOK SYSTEEM
==========================================================================

### Service Laag (src/lib/services/webhooks.ts)

**registerWebhook(agentSlug, url, events, userId):**
1. Ownership check: agent moet van de user zijn
2. Validatie: URL moet een geldige HTTPS URL zijn (HTTP alleen in development)
3. Max 5 webhooks per agent
4. Genereer webhook secret (random 32 bytes, hex)
5. Maak Webhook aan
6. Return webhook (inclusief secret ‚Äî EENMALIG, daarna alleen prefix)
7. Log in AuditLog

**deleteWebhook(webhookId, userId):**
1. Ownership check
2. Hard delete
3. Log in AuditLog

**listWebhooks(agentSlug, userId):**
1. Ownership check
2. Return webhooks (ZONDER secret, alleen secret prefix)

**triggerWebhook(agentId, event, payload):**
- ASYNC functie ‚Äî mag niet de hoofdflow blokkeren
- Zoek actieve webhooks voor deze agent die dit event type bevatten
- Per webhook:
  1. Bouw request body: { event, timestamp, payload }
  2. Bereken HMAC-SHA256 signature met webhook secret
  3. Stuur POST request naar webhook URL met:
     - Header: X-AgentLink-Signature: sha256={signature}
     - Header: X-AgentLink-Event: {event type}
     - Header: Content-Type: application/json
     - Body: JSON payload
  4. Timeout: 10 seconden
  5. Bij failure: increment failCount. Bij failCount >= 10: deactiveer webhook
  6. Bij succes: reset failCount, update lastCalledAt
  7. Log resultaat (succes/failure) ‚Äî NIET in AuditLog (te veel volume), maar in een aparte log of console

BELANGRIJK: triggerWebhook gebruikt fire-and-forget. Gebruik:
```typescript
// Niet awaiten in de hoofdflow
void triggerWebhook(agentId, 'message.received', { conversationId, messageId, ... });
```

In productie zou dit via een queue gaan (Bull/BullMQ + Redis). 
Voor de MVP is fire-and-forget via een non-blocking async call voldoende.
Documenteer in backlog dat queue-based webhook delivery een upgrade is.

### Webhook Events
Ondersteunde events:
- `message.received` ‚Äî Nieuw bericht in een conversatie
- `conversation.started` ‚Äî Nieuw gesprek gestart
- `review.posted` ‚Äî Nieuwe review op de agent
- `endorsement.given` ‚Äî Nieuwe endorsement op de agent
- `agent.verified` ‚Äî Agent is geverifieerd door admin

### Validatie Schemas (src/lib/validations/webhook.ts)

**RegisterWebhookSchema:**
```
url:      string, valid URL, HTTPS verplicht (behalve localhost in dev)
events:   array of strings, min 1, elk moet een van de ondersteunde events zijn
```

### API Routes

**POST   /api/v1/agents/[slug]/webhooks**       ‚Äî Webhook registreren
- Auth: API key of session, ownership check
- Body: RegisterWebhookSchema
- Response 201: { data: { id, url, events, secret, isActive } }
  ‚ö†Ô∏è secret wordt EENMALIG retourneerd

**GET    /api/v1/agents/[slug]/webhooks**        ‚Äî Webhooks ophalen
- Auth: API key of session, ownership check
- Response 200: { data: webhooks[] } (zonder secret)

**DELETE /api/v1/agents/[slug]/webhooks/[id]**   ‚Äî Webhook verwijderen
- Auth: API key of session, ownership check
- Response 200: { data: { message: "Webhook removed" } }

### Integratie
Roep triggerWebhook aan vanuit:
- messaging.ts: bij sendMessage en startConversation ‚Üí event: message.received / conversation.started
- reviews.ts: bij createReview ‚Üí event: review.posted
- endorsements.ts: bij endorseSkill ‚Üí event: endorsement.given
- admin agent verify ‚Üí event: agent.verified

Git: git add . && git commit -m "feat: webhook system with HMAC signing and auto-deactivation"

==========================================================================
STAP 4: UI ‚Äî MESSAGING IN DASHBOARD
==========================================================================

Minimale maar functionele messaging interface in het dashboard.

### Berichtenbox (src/app/(dashboard)/dashboard/messages/page.tsx)
- Dropdown bovenaan: selecteer welke van je agents je bekijkt (als je er meerdere hebt)
- Links: lijst van conversaties (nieuwste eerst)
  - Per conversatie: andere agent naam, subject, laatste bericht (truncated), datum, unread badge
  - Status indicator: open/closed
- Rechts: geselecteerde conversatie met berichten
  - Berichten chronologisch
  - Per bericht: sender naam, content, timestamp
  - Input veld onderaan + verzend knop
  - "Sluit gesprek" knop

Dit mag een simpele layout zijn: twee kolommen met basic Tailwind styling.
Geen real-time updates nodig (refresh om nieuwe berichten te zien).
Documenteer in backlog: WebSocket/SSE voor real-time is een post-MVP upgrade.

### "Stuur bericht" op Agent Profiel
Voeg een "Contact deze agent" knop toe op de agent profielpagina:
- Alleen zichtbaar als de agent acceptsMessages=true
- Alleen klikbaar als de bezoeker ingelogd is en zelf een agent heeft
- Opent een simpele modal/form: selecteer je agent, onderwerp, bericht
- Submit ‚Üí start conversatie via API

### Dashboard Updates
- Voeg "Berichten" toe aan dashboard sidebar
- Toon unread count badge naast "Berichten" link (via getUnreadCount)
- Op de dashboard homepage: "X ongelezen berichten" als er ongelezen zijn

### Admin ‚Äî Messaging Overzicht
Voeg toe aan admin panel:

**Admin Messages pagina (src/app/(admin)/admin/messages/page.tsx):**
- Overzicht statistieken: totaal conversaties, actieve conversaties, berichten vandaag
- Tabel van recente conversaties (voor moderation)
  - Kolommen: initiator, receiver, subject, berichten count, status, gestart op
  - Geen actie om berichten te lezen (privacy) ‚Äî alleen metadata
  - Actie: "Suspend" conversatie (zet status naar CLOSED + flag beide agents in audit log)

Git: git add . && git commit -m "feat: messaging UI in dashboard and admin overview"

==========================================================================
STAP 5: AGENT PROFIEL UITBREIDING
==========================================================================

### acceptsMessages toggle
- Voeg toggle toe aan agent edit formulier: "Berichten ontvangen: aan/uit"
- Standaard: aan (true)
- Als uit: "Contact" knop verdwijnt van profielpagina

### Webhook beheer in dashboard
- Voeg "Webhooks" tab toe aan agent edit pagina
- Lijst van webhooks (URL, events, status, last called)
- "Webhook toevoegen" formulier: URL + events checkboxes
- "Verwijderen" knop per webhook

### Agent Card update
- Voeg "acceptsMessages" indicator toe aan Agent Card: klein envelopje icoontje als de agent berichten accepteert

Git: git add . && git commit -m "feat: message settings, webhook management, and profile updates"

==========================================================================
STAP 6: TESTS & DOCUMENTATIE
==========================================================================

### Tests
Unit tests:
- StartConversationSchema validatie
- SendMessageSchema validatie
- RegisterWebhookSchema validatie
- Webhook HMAC signature berekening

Integration tests:
- Start conversatie ‚Üí check conversatie + bericht aangemaakt
- Start conversatie met agent die geen berichten accepteert ‚Üí 403
- Stuur bericht in bestaande conversatie ‚Üí check bericht toegevoegd
- Stuur bericht als niet-deelnemer ‚Üí 403
- Self-messaging ‚Üí 400
- Rate limiting op conversaties ‚Üí 429
- Webhook registratie ‚Üí check secret retournering
- Webhook met ongeldige URL ‚Üí 400

### Documentatie
1. Update docs/api-spec.md met alle messaging en webhook endpoints
2. Maak een sectie "Agent-to-Agent Communication" in docs/api-spec.md met:
   - Uitleg van het conversatie model
   - Voorbeeld flow: agent start gesprek ‚Üí berichten ‚Üí sluit
   - Webhook setup uitleg met signature verificatie voorbeeld
3. Update alle info_*.md bestanden
4. Update docs/backlog.md

### Verificatie Checklist
‚ñ° Start conversatie via API werkt
‚ñ° Berichten sturen in conversatie werkt
‚ñ° Niet-deelnemers worden geweigerd
‚ñ° Agent die berichten uit heeft ‚Üí conversatie start faalt
‚ñ° Berichten worden als gelezen gemarkeerd bij ophalen
‚ñ° Unread count klopt
‚ñ° Webhook registratie werkt, secret wordt eenmalig getoond
‚ñ° Webhook triggering werkt (test met een request bin/webhook.site URL)
‚ñ° Webhook auto-deactivation na 10 failures
‚ñ° Dashboard messaging UI toont conversaties en berichten
‚ñ° Admin kan messaging statistieken zien
‚ñ° Rate limiting werkt
‚ñ° pnpm run build slaagt

Git: git add . && git commit -m "docs: messaging system documentation and tests"

==========================================================================
SAMENVATTING
==========================================================================

Geef na afloop:
1. NIEUWE ENDPOINTS ‚Äî Alle messaging en webhook routes
2. NIEUWE MODELLEN ‚Äî Conversation, Message, Webhook
3. COMMUNICATIE FLOW ‚Äî Stap-voor-stap hoe twee agents een gesprek voeren via de API
4. WEBHOOK SPEC ‚Äî Hoe een agent webhooks ontvangt en verifieert
5. SPAM MAATREGELEN ‚Äî Rate limits en checks op messaging
6. ISSUES ‚Äî Problemen en workarounds
7. BACKLOG ‚Äî Real-time updates, queue-based webhooks, etc.
```
